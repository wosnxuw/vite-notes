# 正则表达式

https://www.runoob.com/regexp/regexp-rule.html

https://regex-vis.com/

### 正则式

`^` 匹配输入字符串的开始

`$` 匹配输入字符串的结束

比如说，正则式`[0-9]`+可以匹配多个数字

在 dfa113 可能找到 113，但是`^[0-9]+`只能匹配开头是数字的

一个正则表达式以`^`开头并以`$`结尾，说明它想整个匹配一个字符串，而不是其中一部分，即精确匹配

`*` 匹配前面的**模式**零次或多次

`+` 匹配前面的模式一次或多次

`?`  匹配前面的模式 0 次或 1 次

前面的模式，一般来说可能是一个中括号包裹的东西（当然也可以是直白的一个字符）

`^[0-9]+$`表示数字

`{}` 的作用和 `*` 类似，不过更加具体

`{n}` 表示恰好 n 次

`{n,}` 表示 n 次 及以上

`{n,m}` 表示至少 n 次，但是不超过 m（可以等于）

`[]` 中括号是最重要一个概念，可以表达 **1 个** 可以变化的字符

`[^]` 不想要里面的

`.` 是一个特殊字符，可以表达 **1 个** 任意字符（一个 char），但不包括 `\n`

即匹配任何字符串应该是 `.*` （包括空串）

技巧，当你匹配字符串中的内容时，应该考虑`[^\"]`

捕获组

`()`

非捕获组

`(?: ...)`

断言

`(?= ...)`

修饰符（标记）

用于指定额外的匹配策略

### C++

在 C++里，一个正则表达式，表现为一个字符串，即`"a.*c"`，因此没有办法添加额外标记

想要添加，必须在构造函数中传递额外参数

备注：据称 C++标准库里的 regex 性能很是拉跨，最好不用

```C++
std::regex pattern1("a.*c", std::regex_constants::icase); // 使用 icase 标志进行不区分大小写的匹配
```

### re 模块

函数：

match，从头匹配

search，匹配一个

findall，全部匹配，直接返回数组。不需要使用 group。

https://www.runoob.com/python3/python3-reg-expressions.html

`match.group(0)` 返回匹配到的所有内容

`match.group(1)` 返回匹配到的第一个匹配组匹配到的内容，这允许你对匹配的内容轻松分隔

举个例子，`[a-zA-Z0-9_]+\{` 之前匹配这个，还得把`{`去掉，如果写成`([a-zA-Z0-9_]+)\{`则可以直接拿第一匹配组的东西

### 实战演练

```
复杂正则式解释：
r"\b([a-zA-Z_][a-zA-Z_0-9]*)\s*=\s*(?:\"[^\"]*\"|[^,{}]+?)(?=,|})"
\b 是一个元字符 匹配单词的边界
([a-zA-Z_][a-zA-Z_0-9]*) 用括号表示一个捕获组，然后匹配到 C 风格变量名
\s 是一个元字符，表示任何空白字符，这里其实写不写都行
(?:\"[^\"]*\"|[^,{}]+?) 用 (?:) 匹配的非捕获组，捕获等号后续的值
等号后续，有可能是字符串（并且内部包含等号），有可能只是一个变量名或数值型字面量
\" 用于对引号的转义
| 表示或
? 表示贪婪
(?=,|}) 是一个断言，要求最后一定以，或者}收尾
```
