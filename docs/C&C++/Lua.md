# Lua

Lua 是解释型语言，即使用 lua.exe 对 lua 源代码进行解释执行

lua.exe 的源代码由纯 ANSI C 写成，并且轻量级，可以在任何平台（尤其是嵌入式平台）编译，这使得 Lua 不像 python 那样，一定要运行在主流操作系统上

同时你可以定制你的 lua，比如编译为 lib 或 dll。 在 Unix 下，我们建议把 Lua 库静态链入宿主程序，然后将符号导出用于动态链接。 在 Windows 下，我们建议把 Lua 库编译成一个 DLL 。

#### 数据类型

1、nil 类似 None NULL，给变量赋值 nil，垃圾回收器会回收其内存

2、true 和 flase

3、浮点数（Lua 没有整数）

4、string （单引号或双引号均可）（用 .. 拼接字符串）

5、table 表，关联数组。

#### 表的创建

表可以通过”构造表达式“来创建 {}是一种构造表达式

```lua
t1 = {}
t2 = {"apple", "pear"}
```

遍历一个表，Lua 的索引从 1 开始

```lua
for k, v in pairs(t2) do
	print(k .. ":" .. v)
end
```

表，实际上是一个映射，一个 Map

当不指定键的时候，键默认是从 1 开始增长

同时，表没有大小，可以随意增长

表的键的类型也不固定

```Lua
a = {}
a["key"] = "value"
key = 10
a[key] = 22
```

当索引是字符串时，允许使用 . 进行访问

即 a.key 可以访问到 22

同时，表的变量名有些类似 Python，是一个指针

表可以直接赋值给另一个变量，它们共享同一个表实体

#### 遍历创建与作用域

Lua 的遍历默认是全局的，不管它在不在函数里

只有写了 local 声明以后，作用域缩小到所在 Block

```Lua
function joke()
    c = 5           -- 全局变量
    local d = 6     -- 局部变量
end

joke()
print(c,d)          --> 5 nil
```

多赋值

不允许：

```
a, b, c = 0 --这个只能给 a 赋值
a, b, c = 0, 1, 2 --合理
```

换行符：

分号；可以显式的分割语句（尤其是一行内）

Lua 不强制写分号，换行就等于写分号了

#### 表的进一步探讨

```Lua
a={key=22,"key"="value"}
```

上面这个是非法的，

Lua 你用{}建立表的时候，如果你不给定键的类型，那么键默认是一个字符串类型

你能够使用 . 来访问，即

```lua
a={key=22}
a={"key"=22}
```

应该是一回事。

a={key=22} 能够用 a["key"] 访问

之所以之前那个成立，是因为 key 是一个数，本质上是和下面一样

```lua
a[10]=22
```

#### 函数定义和调用

```lua
t_g = {INT0 = 0}
t_p = {INT0 = 0}

function BitOr(params)
    print(params.operateInt)
    print(params.compareInt)
end

BitOr{operateInt=t_g.INT0, compareInt=t_p.INT0}
```

函数调用的时候，可以现场构造一个参数表，这样可以不使用小括号，只使用大括号

params，这个叫什么无所谓，只不过是代表了一个表

operateInt，这个必须对应上，否则它找不到。传实参时，不写大概率是不行的，因为你不写，等价于传 1 2 3（双精度浮点数）作为键。

**传参**

基本类型（含字符串）传递值

表 传递引用

**返回值**

函数可以有返回值，使用 return 返回即可