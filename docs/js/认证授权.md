**RESTful API**

名称来源于 **REST**（Representational State Transfer，表述性状态转移），这是 Roy Fielding 在 2000 年的博士论文中提出的一种软件架构风格

表述性：指资源可以用多种形式表述，如 JSON、XML。API 通过传输资源的表述来操作资源，而不是直接操作资源本身

状态转移：指通过请求来改变资源的状态

REST 强调**资源为中心**的设计。每个资源有唯一标识（URI），并通过标准的 HTTP 方法进行操作

**HTTP 协议无状态**

服务器默认情况下无法区分两个连续的请求是否来自同一个用户，或者同一个用户之前的操作是什么。

这就像一个“健忘”的服务员，每次你跟他说话，他都不知道你是谁，也不知道你之前点过什么菜。

无状态指：服务器不会记录客户端的状态，并不是指每次请求都是函数式编程的无副作用，是指服务器不能依赖于之前请求保存的上下文

在分布式系统中，无状态似乎是更优的设计哲学

**登记住录**

主流是两种方式

1、Session+Cookie

2、JWT

都是**在无状态协议上建立有状态会话**的方法

**Session+Cookie**

Session：会话

用户登录后，服务器创建一个 Session 对象，把 SessionID 给用户，浏览器把它保存到 Cookie 里，后续所有请求都会附带 Cookie，服务器从 Cookie 里拿 SessionID 找到用户

类似大模型的 API-key，只不过 SessionID 时效性较短

服务器里，`SessionID` 一般会选择存放在 Redis 中，服务器通过 HTTP 响应头中的 `Set-Cookie` 指令，把这个 `SessionID` 发送给用户的浏览器

问题：

1、多服务器同步。如果 A 给你分配 SessionID，然后你又被负载均衡器分配到 B 服务器，B 不认识你。

2、CSRF

CSRF(Cross Site Request Forgery) 一般被翻译为 **跨站请求伪造**

就是说，你在访问 A 网站时，里面可能包含一个来源于 B 网站的代码，B 网站的代码的内容是，向 A 网站发起一个请求。你如果点击了或者加载了，你就会自己向 A 网站发送请求，此时，浏览器会默认附带 Cookie，所以被攻击

（1）B 网站服务器本身不参与攻击，只是提供恶意代码，操作是你自己引发的

（2）请求默认附带 Cookie 是问题根源

**JWT**

JWT - JSON Web Tokens

和前面类似，只是登录后，返回的是 Token，客户端把 Token 存储起来，然后每次 Header 中附带 Token，服务器检查 Token

它可以解决 CSRF 攻击，原因是 Token 放在 `localStorage` （浏览器本地存储）中。前端框架，通过代码，把 Token 放在**请求头**里，而不是浏览器默认的行为

当然，如果有人能拿到你的 localStorage，一样能攻击，XSS（跨站脚本攻击）。

优势：

JWT 自身包含了身份验证所需要的所有信息，符合 RESTful 的无状态设计原则，即多个服务器不需要自己记录 SessionID，解决同步问题

JWT 通常是这样的：`xxxxx.yyyyy.zzzzz`

由三个  base64 编码组成，分为：头部+负载+签名

```txt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

头部：

```json
{
  "alg": "HS256", //加密算法类型 Algorithm
  "typ": "JWT" //类型，是 JWT
}
```

负载：

```json
{
  "uid": "ff1212f5-d8d1-4496-bf41-d2dda73de19a",
  "sub": "1234567890",
  "name": "John Doe",
  "exp": 15323232, // JWT 的过期时间
  "iat": 1516239022, // JWT 签发时间
  "scope": ["admin", "user"]
}
```