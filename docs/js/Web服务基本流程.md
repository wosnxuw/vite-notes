在我们 HTTP 的文档里，我们说明了

HTTP 请求的请求行包含路径

这一点在我们用 FastAPI 时，可以用 @app.post("/v1/chat/completions") 直接指定对应的函数，也可以像那个 rust 例子那样，手工拆解，反正是对应一个函数

现在是这样的

1、你访问 deepseek.com

deepseek 的前端服务器给你提供界面，这个界面 html 里包含一些已经写好的 js 函数（如何 get 这个前端我们先忽略）

2、你点击了发送消息

前端界面里的 js 函数被触发，js 代码代你去访问 api.deepseek.com/v1 去问问题

3、

你通过 api.deepseek.com 请求数据，这个虽然是后端请求，但是**它也是运行在 https 上**的，所以你本质上要访问某个服务器的 443 端口

4、

你去 DNS 服务器找这个 api.deepseek.com 的 ip，这里有时候有负载均衡设置，负载均衡器会给你直接配置一个就近的服务器 ip 给你

5、你构建一个 https 请求，其中路径是 v1，端口是 443，访问的了某个 1.2.3.4 服务器

6、这个服务器里有一个 Nginx 程序，做反向代理。在 linux 里，监听 1024 以下端口需要 root，它把 443 端口的流量转发到**本机 8000**

（也可以直接返回静态资源，或者过滤等等）

7、你的后端程序 FASTAPI 等等跑在 8000 端口上监听，只接受本地连接。只负责拆解请求行，不管到底是哪个 ip 来的

8、补充：Nginx 在 443 上也可以拆分 https 请求行，把不同的 v1 v2 转发到不同程序上